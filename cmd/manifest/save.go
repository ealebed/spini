/*
Copyright Â© 2022 Yevhen Lebid ealebed@gmail.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manifest

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/spf13/cobra"

	"github.com/ealebed/spini/types"
	"github.com/ealebed/spini/utils"
)

// saveOptions represents options for save command
type saveOptions struct {
	*manifestOptions
	applicationName string
	localConfig     bool
	repositoryName  string
	commitMessage   string
	prSubject       string
	branch          string
}

// NewSaveCmd returns new save manifest command
func NewSaveCmd(manifestOptions *manifestOptions) *cobra.Command {
	options := &saveOptions{
		manifestOptions: manifestOptions,
	}

	cmd := &cobra.Command{
		Use:     "save",
		Aliases: []string{"create", "generate"},
		Short:   "create or update yaml manifest(s) for provided application",
		Long:    "create or update yaml manifest(s) for provided application",
		Example: "spini manifest save [--template=...] [--name=...] [--repo=...]",
		RunE: func(cmd *cobra.Command, args []string) error {
			return saveManifest(cmd, options)
		},
	}

	cmd.Flags().StringVarP(&options.applicationName, "name", "n", "", "application name for creating manifest")
	cmd.Flags().BoolVar(&options.localConfig, "local", true, "read local configuration.json")
	cmd.Flags().StringVarP(&options.repositoryName, "repo", "r", "", "GitHub repository name to generate applications manifests from")
	cmd.Flags().StringVarP(&options.branch, "branch", "b", "master", "branch to read configuration.json from")
	cmd.Flags().StringVar(&options.prSubject, "pr-title", "Update",
		"title of the pull request (by default `Update $appName`). "+
			"If not specified, no pull request will be created")
	cmd.Flags().StringVar(&options.commitMessage, "commit-message", "Update autogenerated manifests for",
		"content of the commit message (by default `Update autogenerated manifests for $appName`)")

	if err := cmd.MarkFlagRequired("name"); err != nil {
		return nil
	}

	return cmd
}

// saveManifest creates manifest (or updates if already exists) in github repository
func saveManifest(_ *cobra.Command, options *saveOptions) error {
	configResponse := utils.LoadConfiguration(options.localConfig, options.Organization, options.repositoryName, options.branch)

	for _, app := range configResponse {
		if app.Application == options.applicationName {
			if !app.SkipAutogeneration {
				for _, profile := range *app.Profiles {
					for _, tier := range *profile.Datacenters {
						filePath := utils.GenerateManifests(app, tier, profile.ProfileName, options.Organization)

						str = append(str, filePath+":"+filePath)
						rmStr = append(rmStr, filePath)
					}
				}
			} else {
				fmt.Println("Skip " + app.Application + " due to skip flag")
				os.Exit(0)
			}
		}
	}
	sourceFiles := strings.Join(str, ",")

	if options.DryRun {
		fmt.Println("[DRY_RUN] Generate yaml-manifest(s):\n", strings.Join(str, "\n"))
	} else {
		PROptions := &types.PullRequestOptions{
			Organization:   options.Organization,
			RepositoryName: options.GitHubRepositoryName,
			AuthorName:     options.GitHubUser,
			AuthorEmail:    options.GitHubEmail,
			PRSubject:      options.prSubject + " " + options.applicationName,
			PRDescription:  "Update *.yaml manifests for application " + options.applicationName,
			CommitMessage:  options.commitMessage + " " + options.applicationName,
			CommitBranch:   "update_" + time.Now().Format("2006-01-02-1504"),
		}

		if err := utils.CreatePullRequest(sourceFiles, PROptions); err != nil {
			return fmt.Errorf("failed to create pull request: %w", err)
		}

		fmt.Println("\nManifest(s) save succeeded")

		// Remove generated yaml files
		for _, file := range rmStr {
			if err := os.Remove(file); err != nil {
				return fmt.Errorf("failed to remove file %s: %w", file, err)
			}
		}
	}

	return nil
}
