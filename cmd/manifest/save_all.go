/*
Copyright Â© 2022 Yevhen Lebid ealebed@gmail.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manifest

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/spf13/cobra"

	"github.com/ealebed/spini/types"
	"github.com/ealebed/spini/utils"
)

// saveAllOptions represents options for save-all command
type saveAllOptions struct {
	*manifestOptions
	localConfig    bool
	repositoryName string
	commitMessage  string
	prSubject      string
	branch         string
}

// NewSaveAllCmd returns new save-all manifest command
func NewSaveAllCmd(manifestOptions *manifestOptions) *cobra.Command {
	options := &saveAllOptions{
		manifestOptions: manifestOptions,
	}

	cmd := &cobra.Command{
		Use:     "save-all",
		Aliases: []string{"create-all", "generate-all"},
		Short:   "create or update yaml manifest(s) for all applications from provided GitHub repository",
		Long:    "create or update yaml manifest(s) for all applications from provided GitHub repository",
		Example: "spini manifest save-all [--template=...] [--repo=...]",
		RunE: func(cmd *cobra.Command, args []string) error {
			return saveAllManifest(cmd, options)
		},
	}

	cmd.Flags().BoolVar(&options.localConfig, "local", true, "read local configuration.json")
	cmd.Flags().StringVarP(&options.repositoryName, "repo", "r", "", "GitHub repository name to generate applications manifests from")
	cmd.Flags().StringVarP(&options.branch, "branch", "b", "master", "branch to read configuration.json from")
	cmd.Flags().StringVar(&options.prSubject, "pr-title", "Update autogenerated manifests",
		"title of the pull request (by default `Update autogenerated manifests`). "+
			"If not specified, no pull request will be created")
	cmd.Flags().StringVar(&options.commitMessage, "commit-message", "Update autogenerated manifests",
		"content of the commit message (by default `Update autogenerated manifests`)")

	if err := cmd.MarkFlagRequired("repo"); err != nil {
		return nil
	}

	return cmd
}

// saveAllManifest creates manifests (or updates if already exists) for all applications in github repository
func saveAllManifest(_ *cobra.Command, options *saveAllOptions) error {
	configResponse := utils.LoadConfiguration(options.localConfig, options.Organization, options.repositoryName, options.branch)

	for _, app := range configResponse {
		if !app.SkipAutogeneration {
			for _, profile := range *app.Profiles {
				for _, tier := range *profile.Datacenters {
					filePath := utils.GenerateManifests(app, tier, profile.ProfileName, options.Organization)

					str = append(str, filePath+":"+filePath)
					rmStr = append(rmStr, filePath)
				}
			}
		} else {
			fmt.Println("Skip " + app.Application + " due to skip flag")
		}
	}
	sourceFiles := strings.Join(str, ",")

	if options.DryRun {
		fmt.Println("[DRY_RUN] Generate yaml-manifest(s):\n", strings.Join(str, "\n"))
	} else {
		PROptions := &types.PullRequestOptions{
			Organization:   options.Organization,
			RepositoryName: options.GitHubRepositoryName,
			AuthorName:     options.GitHubUser,
			AuthorEmail:    options.GitHubEmail,
			PRSubject:      options.prSubject,
			PRDescription:  "Update autogenerated *.yaml manifests for applications",
			CommitMessage:  options.commitMessage,
			CommitBranch:   "update_" + time.Now().Format("2006-01-02-1504"),
		}

		if err := utils.CreatePullRequest(sourceFiles, PROptions); err != nil {
			return fmt.Errorf("failed to create pull request: %w", err)
		}

		fmt.Println("\nManifest(s) save succeeded")

		// Remove generated yaml files
		for _, file := range rmStr {
			if err := os.Remove(file); err != nil {
				return fmt.Errorf("failed to remove file %s: %w", file, err)
			}
		}
	}

	return nil
}
